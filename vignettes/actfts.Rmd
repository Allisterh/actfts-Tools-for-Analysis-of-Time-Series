---
title: "actfts"
output:
  rmarkdown::html_vignette:
    self_contained: false
vignette: >
  %\VignetteIndexEntry{actfts}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style>
  body {
    text-align: justify;
  }
</style>

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, warning = FALSE, message = FALSE}
library(actfts)
```

# Motivation

The development of this package addresses the need to consolidate various concepts related to time series analysis, which current R packages approach separately. By integrating these tools into one package, educators can focus on teaching and understanding time series analysis without dealing with fragmented code across multiple resources. This integration provides a more coherent and efficient teaching experience by creating a unified and streamlined environment.

Moreover, this package aims to simplify the process for students by eliminating the complexities of managing scattered code. Students can then concentrate on analyzing data and interpreting results. By easing access to and application of time series analysis techniques, the package helps students gain a deeper, more practical understanding of the concepts without being overwhelmed by the need to navigate multiple tools and syntaxes. This approach enhances the overall quality of teaching and learning in time series analysis.

# Data

This package features a three-time series that automatically updates from the FRED database of the United States. These datasets let you practice using the package's functions. Below, we describe each of them:

**Gross Domestic Product**, GDP is a comprehensive measure that quantifies the total monetary value of all goods and services produced within a country over a specific period, usually a quarter or a year. It provides a comprehensive overview of a nation's economic activity, reflecting its health and size. Economists often use GDP to compare the economic performance of different countries or regions and assess economic policies' impact.

Here's a practical code that allows you to obtain GDP data.

```{r}
GDP_data <- actfts::GDPEEUU
head(GDP_data)
```

**Personal Consumption Expenditures** represents the total value of goods and services that households and nonprofit institutions serving households consume within an economy. As a critical component of GDP, PCE reveals consumer behavior and spending patterns. It covers expenditures on durable goods, non-durable goods, and services, offering insights into consumer confidence and living standards.

Here's a practical code that allows you to obtain PCE data.

```{r}
PCEC_data <- actfts::PCECEEUU
head(PCEC_data)
```

**Disposable Personal Income** indicates how much money households spend and save after paying taxes and other mandatory charges. It serves as a crucial indicator of consumer purchasing power and financial well-being. DPI directly influences consumer spending and saving decisions, affecting overall economic growth. Analysts often examine DPI to understand trends in personal savings rates and consumption patterns.

Here's a practical code that allows you to obtain DPI data.

```{r}
DPI_data <- actfts::DPIEEUU
head(DPI_data)
```

# Applied Example

## Example one

In this first example, we will analyze the United States GDP time series. We will use the `acfinter()` function to see the ACF, PACF, Box_Pierce, Pv_Box, Ljung_Box, and Pv_Ljung. We can also see the normality analysis and stationarity analysis. Finally, a plot with ACF, PACF, and Pv LJUNG BOX.

Therefore, we will use the following code to analyze the first ten lags and explain each result of the `acfinter()` function.

```{r}
result <- acfinter(GDP_data, lag = 10)
print(result)
```

```{r echo=FALSE, fig.align='center', message=FALSE, warning=FALSE, , fig.dim=c(7.6, 4)}
library(dplyr)
library(plotly)

ldata <- nrow(GDP_data)
result <- acfinter(GDP_data, lag = 10)
table <- result$`ACF-PACF Test`

get_clim1 <- function(x, ci=0.95, ci.type="white"){
  if (!ci.type %in% c("white", "ma")) stop('`ci.type` must be "white" or "ma"')
  clim0 <- qnorm((1 + ci)/2) / sqrt(ldata)
  if (ci.type == "ma") {
    clim <- clim0 * sqrt(cumsum(c(1, 2 * table$acf^2)))
    return(clim[-length(clim)])
  } else {
    lineci1 <- rep(clim0, NROW(table$acf))
    return(lineci1)
  }
}

get_clim2 <- function(x, ci=0.95, ci.type="white"){
  if (!ci.type %in% c("white", "ma")) stop('`ci.type` must be "white" or "ma"')
  clim0 <- qnorm((1 + ci)/2) / sqrt(ldata)
  if (ci.type == "ma") {
    clim <- clim0 * sqrt(cumsum(c(1, 2 * table$pacf^2)))
    return(clim[-length(clim)])
  } else {
    lineci2 <- rep(clim0, NROW(table$pacf))
    return(lineci2)
  }
}

saveci1 <- get_clim1(table$acf)
saveci2 <- get_clim2(table$pacf)

lag <- 10

fig1 <- plot_ly(
  x = table$lag,
  y = table$acf,
  type = "bar",
  name = "acf",
  color = I("slategray"),
  cliponaxis = FALSE,
  showlegend = FALSE
) %>%
  layout(bargap = 0.7,
         xaxis = list(range = c(1,lag)))

fig1 <- fig1 %>% add_trace(
  y = saveci1,
  type = 'scatter',
  mode = 'lines',
  showlegend = FALSE,
  cliponaxis = FALSE,
  line = list(width = 0.8, dash = "dash", color="black")
)

fig1 <- fig1 %>% add_trace(
  y = -saveci1,
  type = 'scatter',
  mode = 'lines',
  showlegend = FALSE,
  cliponaxis = FALSE,
  line = list(width = 0.8, dash = "dash", color="black")
)

fig2 <- plot_ly(
  x = table$lag,
  y = table$pacf,
  type = "bar",
  name = "pacf",
  color = I("dimgrey"),
  cliponaxis = FALSE,
  showlegend = FALSE
) %>%
  layout(bargap = 0.7,
         xaxis = list(range = c(1,lag)))

fig2 <- fig2 %>% add_trace(
  y = saveci2,
  type = 'scatter',
  mode = 'lines',
  showlegend = FALSE,
  cliponaxis = FALSE,
  line = list(width = 0.8, dash = "dash", color="black")
)

fig2 <- fig2 %>% add_trace(
  y = -saveci2,
  type = 'scatter',
  mode = 'lines',
  showlegend = FALSE,
  cliponaxis = FALSE,
  line = list(width = 0.8, dash = "dash", color="black")
)

hline <- function(y = 0, color = "black") {
  list(type = "line", x0 = 0, x1 = 1, xref = "paper", y0 = y, y1 = y,
       line = list(color = color, dash = "dash")
  )
}

fig3 <- plot_ly(
  x = table$lag,
  y = table$Pv_Ljung,
  type = "scatter",
  mode = "markers",
  name = "Pv Ljung Box",
  color = I("lightslategrey"),
  cliponaxis = FALSE,
  showlegend = FALSE
) %>%
  layout(shapes = hline(0.05),
         xaxis = list(range = c(0.5,lag+0.5)))

fig <- subplot(fig1, fig2, fig3, nrows = 3, shareX = TRUE, margin = 0.07) %>%
  layout(
    xaxis = list(
      title = "lags",
      dtick = 1,
      tick0 = 1,
      tickmode = "linear"
    )
  )

htmltools::tagList(fig)
```

The `result` variable contains three primary tests: ACF-PACF, Stationary, and Normality. For the ACF-PACF component, we observe significant correlations at multiple lags, suggesting a trend component in the GDP time series. We can also watch this result in the plot.

Regarding the stationary tests, the `acfinter()` function provides ADF, KPSS-Level, KPSS-Trend, and PP results. While each test has nuances, they aim to determine if the series is stationary. Both the ADF and PP tests yield p-values of 0.99. Since these values exceed the significance level (in this case, 0.95), we reject the null hypothesis of stationarity, confirming the presence of a unit root and a trend component in the GDP time series.

On the other hand, we have the KPSS-Level and KPSS-Trend tests. Both the KPSS-Level and KPSS-Trend tests yielded p-values of 0.01. The result indicates that we reject the null hypothesis for both tests, suggesting that the time series is non-stationary, neither at level nor trend.

Concerning the third component, based on the Shapiro-Wilks and Kolmogorov-Smirnov normality tests, we concluded that the time series data does not follow a normal distribution. This is because the results led us to reject the null hypothesis of normality.

Finally, we conducted a Box-Cox transformation test to determine if a transformation was necessary to stabilize the time series variance. Based on the test results, we can apply some of these transformations:

* 1: No transformation.
* 0: Natural logarithm.
* 0.5: Square root.
* 2: Square.
* -1: Inverse.

The results in both tests are near 0, so the tests show we should apply to natural logarithm transformation.

## Example two

We've discussed the output of the `acfinter()` function. In the following examples, we'll explore how to use each function argument and provide important considerations for its correct application.

Let's examine the `ci.method` and `ci` arguments. The `ci.method` argument lets us select either constant confidence intervals ("white") or dynamic confidence intervals ("ma"). As for the `ci` argument, you can specify any desired value. 

If we can use these arguments, we will define to `ci.method` argument ma value whereas `ci` argument we will define a confidence interval of 0.98. So, we can use the following code below:

```{r}
result <- acfinter(GDP_data, lag = 10, ci.method = "ma", ci = 0.98)
print(result)
```

```{r echo=FALSE, fig.align='center', message=FALSE, warning=FALSE, , fig.dim=c(7.6, 4)}
library(dplyr)
library(plotly)

ldata <- nrow(GDP_data)
result <- acfinter(GDP_data, lag = 10, ci.method = "ma", ci = 0.98)
table <- result$`ACF-PACF Test`

get_clim1 <- function(x, ci=0.95, ci.type="white"){
  if (!ci.type %in% c("white", "ma")) stop('`ci.type` must be "white" or "ma"')
  clim0 <- qnorm((1 + ci)/2) / sqrt(ldata)
  if (ci.type == "ma") {
    clim <- clim0 * sqrt(cumsum(c(1, 2 * table$acf^2)))
    return(clim[-length(clim)])
  } else {
    lineci1 <- rep(clim0, NROW(table$acf))
    return(lineci1)
  }
}

get_clim2 <- function(x, ci=0.95, ci.type="white"){
  if (!ci.type %in% c("white", "ma")) stop('`ci.type` must be "white" or "ma"')
  clim0 <- qnorm((1 + ci)/2) / sqrt(ldata)
  if (ci.type == "ma") {
    clim <- clim0 * sqrt(cumsum(c(1, 2 * table$pacf^2)))
    return(clim[-length(clim)])
  } else {
    lineci2 <- rep(clim0, NROW(table$pacf))
    return(lineci2)
  }
}

saveci1 <- get_clim1(table$acf,ci.type="ma", ci = 0.98)
saveci2 <- get_clim2(table$pacf,ci.type="ma", ci = 0.98)

lag <- 10

fig1 <- plot_ly(
  x = table$lag,
  y = table$acf,
  type = "bar",
  name = "acf",
  color = I("slategray"),
  cliponaxis = FALSE,
  showlegend = FALSE
) %>%
  layout(bargap = 0.7,
         xaxis = list(range = c(1,lag)))

fig1 <- fig1 %>% add_trace(
  y = saveci1,
  type = 'scatter',
  mode = 'lines',
  showlegend = FALSE,
  cliponaxis = FALSE,
  line = list(width = 0.8, dash = "dash", color="black")
)

fig1 <- fig1 %>% add_trace(
  y = -saveci1,
  type = 'scatter',
  mode = 'lines',
  showlegend = FALSE,
  cliponaxis = FALSE,
  line = list(width = 0.8, dash = "dash", color="black")
)

fig2 <- plot_ly(
  x = table$lag,
  y = table$pacf,
  type = "bar",
  name = "pacf",
  color = I("dimgrey"),
  cliponaxis = FALSE,
  showlegend = FALSE
) %>%
  layout(bargap = 0.7,
         xaxis = list(range = c(1,lag)))

fig2 <- fig2 %>% add_trace(
  y = saveci2,
  type = 'scatter',
  mode = 'lines',
  showlegend = FALSE,
  cliponaxis = FALSE,
  line = list(width = 0.8, dash = "dash", color="black")
)

fig2 <- fig2 %>% add_trace(
  y = -saveci2,
  type = 'scatter',
  mode = 'lines',
  showlegend = FALSE,
  cliponaxis = FALSE,
  line = list(width = 0.8, dash = "dash", color="black")
)

hline <- function(y = 0, color = "black") {
  list(type = "line", x0 = 0, x1 = 1, xref = "paper", y0 = y, y1 = y,
       line = list(color = color, dash = "dash")
  )
}

fig3 <- plot_ly(
  x = table$lag,
  y = table$Pv_Ljung,
  type = "scatter",
  mode = "markers",
  name = "Pv Ljung Box",
  color = I("lightslategrey"),
  cliponaxis = FALSE,
  showlegend = FALSE
) %>%
  layout(shapes = hline(0.05),
         xaxis = list(range = c(0.5,lag+0.5)))

fig <- subplot(fig1, fig2, fig3, nrows = 3, shareX = TRUE, margin = 0.07) %>%
  layout(
    xaxis = list(
      title = "lags",
      dtick = 1,
      tick0 = 1,
      tickmode = "linear"
    )
  )

htmltools::tagList(fig)
```

As you can see, the `acfinter()` function with the `ci.method` and `ci` arguments adjust the results based on the specified confidence interval. Additionally, we observe that the plot's confidence intervals are not constant but exhibit dynamic behavior.

# Example 3

To continue with the United States GPD analysis, we can use the `delta` argument to check the first three differences of the time series. For this case, we will analyze the first difference, so we will use the following code to do it.

```{r}
result <- acfinter(GDP_data, lag = 10, delta = "diff1")
print(result)
```

```{r echo=FALSE, fig.align='center', message=FALSE, warning=FALSE, , fig.dim=c(7.6, 4)}
library(dplyr)
library(plotly)

ldata <- nrow(GDP_data)
result <- acfinter(GDP_data, lag = 10, delta = "diff1")
table <- result$`ACF-PACF Test`

get_clim1 <- function(x, ci=0.95, ci.type="white"){
  if (!ci.type %in% c("white", "ma")) stop('`ci.type` must be "white" or "ma"')
  clim0 <- qnorm((1 + ci)/2) / sqrt(ldata)
  if (ci.type == "ma") {
    clim <- clim0 * sqrt(cumsum(c(1, 2 * table$acf^2)))
    return(clim[-length(clim)])
  } else {
    lineci1 <- rep(clim0, NROW(table$acf))
    return(lineci1)
  }
}

get_clim2 <- function(x, ci=0.95, ci.type="white"){
  if (!ci.type %in% c("white", "ma")) stop('`ci.type` must be "white" or "ma"')
  clim0 <- qnorm((1 + ci)/2) / sqrt(ldata)
  if (ci.type == "ma") {
    clim <- clim0 * sqrt(cumsum(c(1, 2 * table$pacf^2)))
    return(clim[-length(clim)])
  } else {
    lineci2 <- rep(clim0, NROW(table$pacf))
    return(lineci2)
  }
}

saveci1 <- get_clim1(table$acf)
saveci2 <- get_clim2(table$pacf)

lag <- 10

fig1 <- plot_ly(
  x = table$lag,
  y = table$acf,
  type = "bar",
  name = "acf",
  color = I("slategray"),
  cliponaxis = FALSE,
  showlegend = FALSE
) %>%
  layout(bargap = 0.7,
         xaxis = list(range = c(1,lag)))

fig1 <- fig1 %>% add_trace(
  y = saveci1,
  type = 'scatter',
  mode = 'lines',
  showlegend = FALSE,
  cliponaxis = FALSE,
  line = list(width = 0.8, dash = "dash", color="black")
)

fig1 <- fig1 %>% add_trace(
  y = -saveci1,
  type = 'scatter',
  mode = 'lines',
  showlegend = FALSE,
  cliponaxis = FALSE,
  line = list(width = 0.8, dash = "dash", color="black")
)

fig2 <- plot_ly(
  x = table$lag,
  y = table$pacf,
  type = "bar",
  name = "pacf",
  color = I("dimgrey"),
  cliponaxis = FALSE,
  showlegend = FALSE
) %>%
  layout(bargap = 0.7,
         xaxis = list(range = c(1,lag)))

fig2 <- fig2 %>% add_trace(
  y = saveci2,
  type = 'scatter',
  mode = 'lines',
  showlegend = FALSE,
  cliponaxis = FALSE,
  line = list(width = 0.8, dash = "dash", color="black")
)

fig2 <- fig2 %>% add_trace(
  y = -saveci2,
  type = 'scatter',
  mode = 'lines',
  showlegend = FALSE,
  cliponaxis = FALSE,
  line = list(width = 0.8, dash = "dash", color="black")
)

hline <- function(y = 0, color = "black") {
  list(type = "line", x0 = 0, x1 = 1, xref = "paper", y0 = y, y1 = y,
       line = list(color = color, dash = "dash")
  )
}

fig3 <- plot_ly(
  x = table$lag,
  y = table$Pv_Ljung,
  type = "scatter",
  mode = "markers",
  name = "Pv Ljung Box",
  color = I("lightslategrey"),
  cliponaxis = FALSE,
  showlegend = FALSE
) %>%
  layout(shapes = hline(0.05),
         xaxis = list(range = c(0.5,lag+0.5)))

fig <- subplot(fig1, fig2, fig3, nrows = 3, shareX = TRUE, margin = 0.07) %>%
  layout(
    xaxis = list(
      title = "lags",
      dtick = 1,
      tick0 = 1,
      tickmode = "linear"
    )
  )

htmltools::tagList(fig)
```


You can see when we use the argument `delta` with a value equal to one. The `acfinter()` function shows all results with the first difference of the time series. So, we will explain the results.

First 

Finally, the `acfinter()` function allows you to view the result interactively. To do this, you need to use the argument interactive and type "acftable" you can view the result in another way.

Additionally, you can download the results of a time series analysis. When you type "TRUE" in the download argument, the function downloads an Excel file with the numeric result and a figure in PNG format containing the ACF, PACF, and Pv Ljung Box Plots. Here's an example of the code you need to use it.

```{r eval=FALSE, include=FALSE}
result <- acfinter(GDP_data, lag = 10, interactive = "acftable", download = TRUE)
print(result)
```

# Final considerations

You can analyze time series in xts, ts, integer, and vector (numeric) formats. So, if you use a different format, the `acfinter()` function won't work. In this case, you must convert your data to any format we initially showed you.

# References

* U.S. Bureau of Economic Analysis, Gross Domestic Product (GDP), retrieved from FRED, Federal Reserve Bank of St. Louis; https://fred.stlouisfed.org/series/GDP.
* U.S. Bureau of Economic Analysis, Personal Consumption Expenditures (PCEC), retrieved from FRED, Federal Reserve Bank of St. Louis; https://fred.stlouisfed.org/series/PCEC
* U.S. Bureau of Economic Analysis, Disposable Personal Income (DPI), retrieved from FRED, Federal Reserve Bank of St. Louis;https://fred.stlouisfed.org/series/DPI




